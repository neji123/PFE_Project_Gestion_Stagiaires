import { Component, OnInit, OnDestroy, inject, signal, computed, effect } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormBuilder, FormGroup, Validators, ReactiveFormsModule, AbstractControl, ValidationErrors } from '@angular/forms';
import { ActivatedRoute, Router } from '@angular/router';
import { Subject, debounceTime, takeUntil, filter, finalize, firstValueFrom } from 'rxjs';
import { toSignal } from '@angular/core/rxjs-interop'; // üîß AJOUT CRUCIAL pour connecter FormControl aux Signals
import { RatingService, CreateRatingDto, UpdateRatingDto, EvaluationType, DetailedEvaluationCriteria, TutorEvaluationCriteria, RatingDetailDto } from '../../../services/Rating/rating.service';
import { UserService } from '../../../services/User/user.service';
import { AuthService } from '../../../Auth/auth-service.service';
import { environment } from '../../../environments/environment';
import { RatingStatus } from '../../../services/Rating/rating.service';
@Component({
  selector: 'app-rating-form',
  standalone: true,
  imports: [CommonModule, ReactiveFormsModule],
  templateUrl: './rating-form.component.html',
  styleUrls: ['./rating-form.component.scss']
})


export class RatingFormComponent implements OnInit, OnDestroy {
  private formBuilder = inject(FormBuilder);
  private ratingService = inject(RatingService);
  private userService = inject(UserService);
  private authService = inject(AuthService);
  private route = inject(ActivatedRoute);
  private router = inject(Router);
  private destroy$ = new Subject<void>();

  // üîß AJOUT: Propri√©t√© environment pour le template
  environment = environment;

userSearchText: string = '';
userDepartmentFilter: string = '';
userRoleFilter: string = '';
filteredAvailableUsers = signal<any[]>([]);
availableRoles = [
  { value: 'Stagiaire', label: 'Stagiaire' },
  { value: 'Tuteur', label: 'Tuteur' },
  { value: 'RHs', label: 'RH' },
  { value: 'Admin', label: 'Admin' }
];
  // Signals pour l'√©tat r√©actif
  isEditMode = signal(false);
  isLoading = signal(false);
  availableUsers = signal<any[]>([]);
  suggestedGeneralScore = signal<number>(3);
  hasUnsavedChanges = signal(false);
  
  // Computed properties
  currentUser = computed(() => this.authService.currentUserValue);
  
  // Form
  ratingForm!: FormGroup;

  // üîß SOLUTION: Bridge entre FormControl et Signals
  private typeFormValueSignal = signal<any>(null);

  // Crit√®res d'√©valuation
  detailedCriteria = [
    { 
      key: 'technicalSkills', 
      label: 'Comp√©tences techniques',
      icon: 'üîß',
      description: 'Ma√Ætrise des outils et technologies'
    },
    { 
      key: 'communication', 
      label: 'Communication',
      icon: 'üí¨',
      description: 'Capacit√© √† communiquer efficacement'
    },
    { 
      key: 'teamwork', 
      label: 'Travail d\'√©quipe',
      icon: 'üë•',
      description: 'Collaboration et esprit d\'√©quipe'
    },
    { 
      key: 'initiative', 
      label: 'Initiative',
      icon: 'üöÄ',
      description: 'Proactivit√© et prise d\'initiative'
    },
    { 
      key: 'punctuality', 
      label: 'Ponctualit√©',
      icon: '‚è∞',
      description: 'Respect des horaires et d√©lais'
    },
    { 
      key: 'problemSolving', 
      label: 'R√©solution de probl√®mes',
      icon: 'üß©',
      description: 'Capacit√© √† analyser et r√©soudre'
    },
    { 
      key: 'adaptability', 
      label: 'Adaptabilit√©',
      icon: 'üîÑ',
      description: 'Flexibilit√© face aux changements'
    },
    { 
      key: 'overallPerformance', 
      label: 'Performance globale',
      icon: 'üéØ',
      description: '√âvaluation g√©n√©rale des r√©sultats'
    }
  ];

  tutorCriteria = [
    { 
      key: 'availability', 
      label: 'Disponibilit√©',
      icon: 'üìÖ',
      description: 'Accessibilit√© et temps accord√©'
    },
    { 
      key: 'guidance', 
      label: 'Accompagnement',
      icon: 'üß≠',
      description: 'Qualit√© de l\'encadrement'
    },
    { 
      key: 'communication', 
      label: 'Communication',
      icon: 'üí¨',
      description: 'Clart√© des explications'
    },
    { 
      key: 'expertise', 
      label: 'Expertise technique',
      icon: 'üéì',
      description: 'Niveau de comp√©tence technique'
    },
    { 
      key: 'support', 
      label: 'Soutien',
      icon: 'ü§ù',
      description: 'Aide et encouragement'
    },
    { 
      key: 'feedback', 
      label: 'Qualit√© du feedback',
      icon: 'üìù',
      description: 'Pertinence des retours'
    },
    { 
      key: 'overallSatisfaction', 
      label: 'Satisfaction globale',
      icon: 'üòä',
      description: 'Satisfaction g√©n√©rale du tutorat'
    }
  ];

  // üîß COMPUTED PROPERTIES CORRIG√âES avec bridge FormControl-Signals
  availableTypes = computed(() => {
    const user = this.currentUser();
    console.log('üîç availableTypes: Current user =', user);
    
    if (!user) return [];

    const types = [];
    
    if (user.role === 'Tuteur') {
      types.push({ value: EvaluationType.TuteurToStagiaire, label: '√âvaluer un stagiaire' });
    }
    
    if (user.role === 'Stagiaire') {
      types.push({ value: EvaluationType.StagiaireToTuteur, label: '√âvaluer mon tuteur' });
    }
    
    if (user.role === 'RHs' || user.role === 'Admin') {
      types.push({ value: EvaluationType.RHToStagiaire, label: '√âvaluer un stagiaire (RH)' });
    }

    console.log('üîç availableTypes: Types disponibles =', types);
    return types;
  });

  showDetailedCriteria = computed(() => {
    // üîß SOLUTION: Utiliser le signal de bridge pour la r√©activit√©
    const typeSignalValue = this.typeFormValueSignal();
    
    if (!this.ratingForm) {
      console.log('üîç showDetailedCriteria: Pas de formulaire');
      return false;
    }
    
    const typeValue = this.ratingForm.get('type')?.value;
    console.log('üîç showDetailedCriteria: Type value =', typeValue, 'Type signal =', typeSignalValue);
    
    const isValid = typeValue !== '' && typeValue !== undefined && typeValue !== null && !isNaN(Number(typeValue));
    console.log('üîç showDetailedCriteria: Is valid =', isValid);
    
    return isValid;
  });

  isEvaluatingTutor = computed(() => {
    // üîß SOLUTION: Utiliser le signal de bridge pour la r√©activit√©
    const typeSignalValue = this.typeFormValueSignal();
    
    if (!this.ratingForm) {
      console.log('üîç isEvaluatingTutor: Pas de formulaire');
      return false;
    }
    
    const typeValue = this.ratingForm.get('type')?.value;
    const result = Number(typeValue) === EvaluationType.StagiaireToTuteur;
    console.log('üîç isEvaluatingTutor: typeValue =', typeValue, 'result =', result);
    
    return result;
  });

  // üîß EFFECT pour forcer la mise √† jour des computed properties
  constructor() {
    effect(() => {
      // Cet effect force Angular √† v√©rifier les computed properties
      // quand les valeurs du formulaire changent
      if (this.ratingForm) {
        const typeValue = this.ratingForm.get('type')?.value;
        console.log('üîÑ Effect: Type value changed to', typeValue);
      }
    });
  }

  ngOnInit() {
    console.log('üöÄ Initialisation RatingFormComponent');
    
    this.initializeForm();
    
    // V√©rification que le formulaire est bien initialis√©
    if (!this.ratingForm) {
      console.error('‚ùå Erreur : Formulaire non initialis√©');
      return;
    }
    
    this.checkEditMode();
    this.loadAvailableUsers();
    this.setupAutoSave();
    this.setupFormValidation();
    
    // üîß SOLUTION: Setup du bridge FormControl-Signals
    this.setupFormToSignalsBridge();
    
    console.log('üîß RatingFormComponent initialis√©');
    console.log('Form valid:', this.ratingForm?.valid);
    console.log('Current user:', this.currentUser());
  }

  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }

  // üîß SOLUTION: Pont entre le formulaire et les signals
  private setupFormToSignalsBridge() {
    if (!this.ratingForm) return;

    // √âcouter les changements du type d'√©valuation
    this.ratingForm.get('type')?.valueChanges
      .pipe(takeUntil(this.destroy$))
      .subscribe(typeValue => {
        console.log('üîÑ Type FormControl changed:', typeValue);
        
        // Mettre √† jour le signal de bridge
        this.typeFormValueSignal.set(typeValue);
        
        // D√©clencher la mise √† jour des computed properties
        setTimeout(() => {
          console.log('üîÑ Apr√®s changement de type:');
          console.log('- showDetailedCriteria():', this.showDetailedCriteria());
          console.log('- isEvaluatingTutor():', this.isEvaluatingTutor());
        }, 0);
      });
  }

  // üìù INITIALISATION DU FORMULAIRE
  private initializeForm() {
    this.ratingForm = this.formBuilder.group({
      evaluatedUserId: ['', [Validators.required]],
      score: [3, [Validators.required, Validators.min(1), Validators.max(5)]],
      comment: ['', [Validators.required, Validators.minLength(10), Validators.maxLength(1000)]],
      type: ['', [Validators.required]],
      evaluationPeriodStart: [''],
      evaluationPeriodEnd: [''],
      stageReference: ['', [Validators.maxLength(100)]],
      
      detailedScores: this.formBuilder.group({
        technicalSkills: [3, [Validators.min(1), Validators.max(5)]],
        communication: [3, [Validators.min(1), Validators.max(5)]],
        teamwork: [3, [Validators.min(1), Validators.max(5)]],
        initiative: [3, [Validators.min(1), Validators.max(5)]],
        punctuality: [3, [Validators.min(1), Validators.max(5)]],
        problemSolving: [3, [Validators.min(1), Validators.max(5)]],
        adaptability: [3, [Validators.min(1), Validators.max(5)]],
        overallPerformance: [3, [Validators.min(1), Validators.max(5)]]
      }),
      
      tutorScores: this.formBuilder.group({
        availability: [3, [Validators.min(1), Validators.max(5)]],
        guidance: [3, [Validators.min(1), Validators.max(5)]],
        communication: [3, [Validators.min(1), Validators.max(5)]],
        expertise: [3, [Validators.min(1), Validators.max(5)]],
        support: [3, [Validators.min(1), Validators.max(5)]],
        feedback: [3, [Validators.min(1), Validators.max(5)]],
        overallSatisfaction: [3, [Validators.min(1), Validators.max(5)]]
      })
    });

    // Ajouter des validateurs personnalis√©s
    this.addCustomValidators();
  }

  // üõ°Ô∏è VALIDATEURS PERSONNALIS√âS
  private addCustomValidators() {
    // Valider que la date de fin est apr√®s la date de d√©but
    this.ratingForm.addValidators(this.dateRangeValidator.bind(this));
    
    // Valider la coh√©rence des scores
    this.ratingForm.get('score')?.addValidators(this.scoreConsistencyValidator.bind(this));
  }

  private dateRangeValidator(group: AbstractControl): ValidationErrors | null {
    const start = group.get('evaluationPeriodStart')?.value;
    const end = group.get('evaluationPeriodEnd')?.value;
    
    if (start && end && new Date(start) >= new Date(end)) {
      return { dateRange: 'La date de fin doit √™tre post√©rieure √† la date de d√©but' };
    }
    return null;
  }

  private scoreConsistencyValidator(control: AbstractControl): ValidationErrors | null {
    if (!this.ratingForm || !control.value) return null;
    
    const generalScore = control.value;
    const isEvaluatingTutor = this.isEvaluatingTutor();
    const scoresGroup = isEvaluatingTutor ? 
      this.ratingForm.get('tutorScores') : 
      this.ratingForm.get('detailedScores');
    
    if (scoresGroup && scoresGroup.value && generalScore) {
      const detailedScores = scoresGroup.value;
      const scores = Object.values(detailedScores) as number[];
      const avgDetailedScore = scores.reduce((sum, score) => sum + score, 0) / scores.length;
      
      const difference = Math.abs(generalScore - avgDetailedScore);
      
      if (difference > 1.5) {
        return { 
          scoreInconsistency: `Le score g√©n√©ral (${generalScore}) est tr√®s diff√©rent de la moyenne des crit√®res d√©taill√©s (${avgDetailedScore.toFixed(1)})` 
        };
      }
    }
    return null;
  }

  // üîÑ SETUP AUTO-SAVE ET VALIDATION
  private setupAutoSave() {
    // Auto-sauvegarde toutes les 30 secondes
    this.ratingForm.valueChanges
      .pipe(
        debounceTime(30000),
        takeUntil(this.destroy$),
        filter(() => this.ratingForm.valid && this.ratingForm.dirty && !this.isLoading())
      )
      .subscribe(() => {
        console.log('üíæ Auto-sauvegarde du brouillon...');
        this.autoSaveDraft();
      });

    // D√©tecter les changements non sauvegard√©s
    this.ratingForm.valueChanges
      .pipe(takeUntil(this.destroy$))
      .subscribe(() => {
        this.hasUnsavedChanges.set(this.ratingForm.dirty);
      });
  }

  private setupFormValidation() {
    // Mise √† jour du score sugg√©r√© quand les crit√®res changent
    const detailedScoresGroup = this.ratingForm.get('detailedScores');
    const tutorScoresGroup = this.ratingForm.get('tutorScores');

    if (detailedScoresGroup) {
      detailedScoresGroup.valueChanges
        .pipe(takeUntil(this.destroy$))
        .subscribe(() => this.updateSuggestedScore());
    }

    if (tutorScoresGroup) {
      tutorScoresGroup.valueChanges
        .pipe(takeUntil(this.destroy$))
        .subscribe(() => this.updateSuggestedScore());
    }
  }

  // üîç CHARGEMENT DES DONN√âES
  private checkEditMode() {
    const ratingId = this.route.snapshot.params['id'];
    if (ratingId && !isNaN(Number(ratingId))) {
      this.isEditMode.set(true);
      this.loadRatingForEdit(Number(ratingId));
    }
  }

private loadAvailableUsers() {
  console.log('üë• Chargement des utilisateurs √©valuables (endpoint optimis√©)...');
  
  // üéØ UTILISATION DE L'ENDPOINT OPTIMIS√â
  this.ratingService.getUsersICanRateNotEvaluated()
    .pipe(takeUntil(this.destroy$))
    .subscribe({
      next: (users) => {
        console.log('‚úÖ Utilisateurs non √©valu√©s charg√©s (endpoint optimis√©):', users);
        console.log('üìä D√©tail:', users.map(u => ({ 
          id: u.id, 
          name: `${u.firstName} ${u.lastName}`, 
          role: u.role,
          department: u.department || u.departement || 'Non d√©fini'
        })));
        
        this.availableUsers.set(users || []);
        
        // üîß NOUVEAU: Validation intelligente des filtres existants
        const filtersChanged = this.validateAndCleanFilters();
        
        if (!filtersChanged) {
          // Si aucun filtre n'a chang√©, initialiser les utilisateurs filtr√©s
          this.filteredAvailableUsers.set([...users]);
          
          // Appliquer les filtres existants s'il y en a
          if (this.userSearchText || this.userDepartmentFilter || this.userRoleFilter) {
            console.log('üîÑ Application des filtres existants...');
            this.filterAvailableUsers();
          }
        }
        // Sinon, validateAndCleanFilters() a d√©j√† appel√© filterAvailableUsers()
        
        // üîç Log pour debug avec informations dynamiques
        if (users.length === 0) {
          console.log('‚ÑπÔ∏è Aucun utilisateur √† √©valuer (tous d√©j√† √©valu√©s ou aucun assign√©)');
        } else {
          console.log(`üéØ ${users.length} utilisateur(s) disponible(s) pour √©valuation`);
          
          const departments = this.getAvailableDepartments();
          const roles = this.getAvailableUserRoles();
          
          console.log('üè¢ D√©partements dynamiques d√©tect√©s:', departments.length > 0 ? departments : 'Aucun');
          console.log('üé≠ R√¥les dynamiques d√©tect√©s:', roles.length > 0 ? roles : 'Aucun');
          
          // Afficher les statistiques d√©taill√©es
          this.getFilterStatistics();
        }
      },
      error: (error) => {
        console.error('‚ùå Erreur lors du chargement des utilisateurs non √©valu√©s:', error);
        this.showErrorMessage('Impossible de charger la liste des utilisateurs √† √©valuer');
        
        // üîß NOUVEAU: Vider aussi les utilisateurs filtr√©s en cas d'erreur
        this.filteredAvailableUsers.set([]);
        
        // üîß Reset des filtres car plus de donn√©es
        this.resetUserFilters();
        
        // üîß FALLBACK: En cas d'erreur, essayer l'ancienne m√©thode
        console.log('üîÑ Tentative avec l\'ancienne m√©thode...');
        this.loadAvailableUsersOldMethod();
      }
    });
}

/**
 * üîß M√âTHODE FALLBACK: Ancienne logique en cas de probl√®me
 */
private loadAvailableUsersOldMethod() {
  this.ratingService.getUsersICanRate()
    .pipe(takeUntil(this.destroy$))
    .subscribe({
      next: (users) => {
        console.log('‚ö†Ô∏è Utilisation de l\'ancienne m√©thode - tous les utilisateurs:', users);
        this.availableUsers.set(users || []);
        
        // Fallback avec des donn√©es de test en d√©veloppement
        if (!environment.production && (!users || users.length === 0)) {
          this.availableUsers.set([
            { id: 1, firstName: 'Test', lastName: 'User', role: 'Stagiaire' },
            { id: 2, firstName: 'Another', lastName: 'User', role: 'Tuteur' }
          ]);
        }
      },
      error: (error) => {
        console.error('‚ùå Erreur avec l\'ancienne m√©thode aussi:', error);
        this.showErrorMessage('Impossible de charger la liste des utilisateurs');
      }
    });
}



  private patchFormWithRating(rating: any) {
    this.ratingForm.patchValue({
      evaluatedUserId: rating.evaluatedUserId,
      score: rating.score,
      comment: rating.comment,
      type: rating.type,
      evaluationPeriodStart: rating.evaluationPeriodStart ? 
        new Date(rating.evaluationPeriodStart).toISOString().split('T')[0] : '',
      evaluationPeriodEnd: rating.evaluationPeriodEnd ? 
        new Date(rating.evaluationPeriodEnd).toISOString().split('T')[0] : '',
      stageReference: rating.stageReference || ''
    });

    if (rating.detailedScores) {
      this.ratingForm.get('detailedScores')?.patchValue(rating.detailedScores);
    }

    if (rating.tutorScores) {
      this.ratingForm.get('tutorScores')?.patchValue(rating.tutorScores);
    }

    // Marquer le formulaire comme pristine apr√®s le chargement
    this.ratingForm.markAsPristine();
    this.hasUnsavedChanges.set(false);
  }

  // üéØ M√âTHODES D'INTERACTION
  onEvaluationTypeChange() {
    const type = this.ratingForm.get('type')?.value;
    console.log('üîÑ Type d\'√©valuation chang√©:', type, typeof type);
    
    // üîß Mettre √† jour le signal de bridge
    this.typeFormValueSignal.set(type);
    
    this.resetScores();
    this.updateSuggestedScore();
    
    // üîß Forcer la mise √† jour imm√©diate des computed properties
    setTimeout(() => {
      console.log('üîÑ Apr√®s onEvaluationTypeChange:');
      console.log('- showDetailedCriteria():', this.showDetailedCriteria());
      console.log('- isEvaluatingTutor():', this.isEvaluatingTutor());
    }, 0);
  }

  private resetScores() {
    const defaultScore = 3;
    
    // R√©initialiser les scores d√©taill√©s
    const detailedScoresGroup = this.ratingForm.get('detailedScores') as FormGroup;
    if (detailedScoresGroup && detailedScoresGroup.controls) {
      Object.keys(detailedScoresGroup.controls).forEach(key => {
        detailedScoresGroup.get(key)?.setValue(defaultScore);
      });
    }

    // R√©initialiser les scores tuteur
    const tutorScoresGroup = this.ratingForm.get('tutorScores') as FormGroup;
    if (tutorScoresGroup && tutorScoresGroup.controls) {
      Object.keys(tutorScoresGroup.controls).forEach(key => {
        tutorScoresGroup.get(key)?.setValue(defaultScore);
      });
    }

    // R√©initialiser le score g√©n√©ral
    this.ratingForm.get('score')?.setValue(defaultScore);
  }

  private updateSuggestedScore() {
  if (!this.ratingForm) return;
  
  const isEvaluatingTutor = this.isEvaluatingTutor();
  const scoresGroup = isEvaluatingTutor ? 
    this.ratingForm.get('tutorScores') as FormGroup : 
    this.ratingForm.get('detailedScores') as FormGroup;
  
  if (scoresGroup && scoresGroup.value) {
    const scores = Object.values(scoresGroup.value) as number[];
    const averageScore = scores.reduce((sum, score) => sum + score, 0) / scores.length;
    this.suggestedGeneralScore.set(Math.round(averageScore * 10) / 10);
  }
}

  getScoreLabel(score: number): string {
    if (score <= 1.5) return 'Tr√®s faible';
    if (score <= 2.5) return 'Faible';
    if (score <= 3.5) return 'Moyen';
    if (score <= 4.5) return 'Bien';
    return 'Excellent';
  }

  // üíæ SAUVEGARDE
 async saveDraft() {
    if (!this.validateForm()) {
      return;
    }

    this.isLoading.set(true);
    
    try {
      if (this.isEditMode()) {
        const updateData = this.prepareUpdateData();
        const ratingId = this.route.snapshot.params['id'];
        
        await firstValueFrom(this.ratingService.updateRating(Number(ratingId), updateData));
        this.showSuccessMessage('Modifications sauvegard√©es avec succ√®s');
      } else {
        const createData = this.prepareCreateData();
        
        const result = await firstValueFrom(this.ratingService.createRating(createData));
        this.showSuccessMessage('Brouillon cr√©√© avec succ√®s');
        
        // Passer en mode √©dition apr√®s cr√©ation
        this.isEditMode.set(true);
        this.router.navigate(['/ratings/edit', result.id], { replaceUrl: true });
      }
      
      this.ratingForm.markAsPristine();
      this.hasUnsavedChanges.set(false);
      
    } catch (error: any) {
      console.error('‚ùå Erreur lors de la sauvegarde:', error);
      this.showErrorMessage(error.message || 'Erreur lors de la sauvegarde');
    } finally {
      this.isLoading.set(false);
    }
  }

  private async autoSaveDraft() {
    if (!this.validateForm() || this.isLoading()) {
      return;
    }

    try {
      if (this.isEditMode()) {
        const updateData = this.prepareUpdateData();
        const ratingId = this.route.snapshot.params['id'];
        
        await firstValueFrom(this.ratingService.updateRating(Number(ratingId), updateData));
        console.log('üíæ Auto-sauvegarde r√©ussie');
      } else {
        const createData = this.prepareCreateData();
        
        const result = await firstValueFrom(this.ratingService.createRating(createData));
        console.log('üíæ Auto-cr√©ation r√©ussie, ID:', result.id);
        
        // Passer en mode √©dition apr√®s la premi√®re cr√©ation
        this.isEditMode.set(true);
        this.router.navigate(['/ratings/edit', result.id], { replaceUrl: true });
      }
      
      this.ratingForm.markAsPristine();
      this.hasUnsavedChanges.set(false);
    } catch (error: any) {
      console.error('‚ùå Erreur auto-sauvegarde:', error);
    }
  }
private originalRating: RatingDetailDto | null = null;
  isSubmitting = signal(false);
  
  // üîß NOUVELLE PROPRI√âT√â COMPUTED pour l'interface utilisateur
  submitButtonText = computed(() => {
    if (this.isSubmitting()) return 'Soumission...';
    if (this.isEditMode()) {
      return this.originalRating?.status === RatingStatus.Draft ? 
        'Mettre √† jour et soumettre' : 
        'Mettre √† jour';
    }
    return 'Cr√©er et soumettre';
  });

  saveButtonText = computed(() => {
    if (this.isLoading()) return 'Sauvegarde...';
    return this.isEditMode() ? 'Sauvegarder les modifications' : 'Sauvegarder comme brouillon';
  });

  // üîß MODIFIER cette m√©thode existante
  private loadRatingForEdit(ratingId: number) {
    this.isLoading.set(true);
    
    this.ratingService.getRatingById(ratingId)
      .pipe(
        takeUntil(this.destroy$),
        finalize(() => this.isLoading.set(false))
      )
      .subscribe({
        next: (rating) => {
          this.originalRating = rating; // üîß STOCKER l'original
          this.patchFormWithRating(rating);
          console.log('‚úÖ √âvaluation charg√©e pour √©dition:', rating.id, 'Status:', rating.status);
        },
        error: (error) => {
          console.error('‚ùå Erreur lors du chargement de l\'√©valuation:', error);
          this.showErrorMessage('Impossible de charger l\'√©valuation');
          this.router.navigate(['/ratings']);
        }
      });
  }
  // üì§ SOUMISSION
 async onSubmit() {
    if (!this.validateForm()) {
      return;
    }

    this.isSubmitting.set(true);
    
    try {
      let rating: RatingDetailDto;
      
      if (this.isEditMode()) {
        // Mode √©dition
        console.log('üìù Mode √©dition - Mise √† jour de l\'√©valuation');
        const updateData = this.prepareUpdateData();
        const ratingId = this.route.snapshot.params['id'];
        
        // Mettre √† jour l'√©valuation
        rating = await firstValueFrom(this.ratingService.updateRating(Number(ratingId), updateData));
        console.log('‚úÖ √âvaluation mise √† jour avec succ√®s');

        // üîß LOGIQUE INTELLIGENTE : Soumettre seulement si c'√©tait un brouillon
        if (this.originalRating?.status === RatingStatus.Draft) {
          console.log('üì§ √âvaluation √©tait un brouillon, soumission pour approbation...');
          
          try {
            rating = await firstValueFrom(this.ratingService.submitRating(rating.id));
            console.log('‚úÖ √âvaluation soumise avec succ√®s');
            this.showSuccessMessage('√âvaluation mise √† jour et soumise avec succ√®s !');
          } catch (submitError: any) {
            // Si la soumission √©choue, l'√©valuation est quand m√™me mise √† jour
            console.warn('‚ö†Ô∏è Mise √† jour r√©ussie mais soumission √©chou√©e:', submitError);
            this.showSuccessMessage('√âvaluation mise √† jour avec succ√®s. Vous pouvez la soumettre manuellement si n√©cessaire.');
          }
        } else {
          // √âvaluation d√©j√† soumise, juste mise √† jour
          console.log('‚ÑπÔ∏è √âvaluation d√©j√† soumise, pas de re-soumission');
          this.showSuccessMessage('√âvaluation mise √† jour avec succ√®s !');
        }
        
      } else {
        // Mode cr√©ation
        console.log('üÜï Mode cr√©ation - Nouvelle √©valuation');
        const createData = this.prepareCreateData();
        
        // Cr√©er l'√©valuation
        rating = await firstValueFrom(this.ratingService.createRating(createData));
        console.log('‚úÖ √âvaluation cr√©√©e avec succ√®s');

        // Soumettre la nouvelle √©valuation
        try {
          rating = await firstValueFrom(this.ratingService.submitRating(rating.id));
          console.log('‚úÖ Nouvelle √©valuation soumise avec succ√®s');
          this.showSuccessMessage('√âvaluation cr√©√©e et soumise avec succ√®s !');
        } catch (submitError: any) {
          console.warn('‚ö†Ô∏è Cr√©ation r√©ussie mais soumission √©chou√©e:', submitError);
          this.showSuccessMessage('√âvaluation cr√©√©e et sauvegard√©e. Vous pouvez la soumettre manuellement.');
        }
      }

      // Marquer comme propre et naviguer
      this.ratingForm.markAsPristine();
      this.hasUnsavedChanges.set(false);
      
      // Navigation intelligente selon le contexte
      setTimeout(() => {
        this.router.navigate(['/ratings']);
      }, 1500);
      
    } catch (error: any) {
      console.error('‚ùå Erreur lors de la soumission:', error);
      this.showErrorMessage(`Erreur: ${error.message || 'Une erreur est survenue lors de la soumission'}`);
    } finally {
      this.isSubmitting.set(false);
    }
  }

  // üîß NOUVELLE M√âTHODE pour soumettre manuellement (si besoin)
  async submitOnly() {
    if (!this.originalRating || this.originalRating.status !== RatingStatus.Draft) {
      this.showErrorMessage('Cette √©valuation ne peut pas √™tre soumise');
      return;
    }

    this.isSubmitting.set(true);
    
    try {
      const ratingId = this.route.snapshot.params['id'];
      await firstValueFrom(this.ratingService.submitRating(Number(ratingId)));
      
      this.showSuccessMessage('√âvaluation soumise avec succ√®s !');
      this.router.navigate(['/ratings']);
      
    } catch (error: any) {
      console.error('‚ùå Erreur lors de la soumission:', error);
      this.showErrorMessage(`Erreur: ${error.message || 'Impossible de soumettre l\'√©valuation'}`);
    } finally {
      this.isSubmitting.set(false);
    }
  }

  // üõ°Ô∏è VALIDATION
  private validateForm(): boolean {
    if (!this.ratingForm) {
      console.error('Formulaire non initialis√©');
      return false;
    }
    
    if (!this.ratingForm.valid) {
      this.markFormGroupTouched(this.ratingForm);
      this.showValidationErrors();
      return false;
    }
    return true;
  }

  private markFormGroupTouched(formGroup: FormGroup) {
    if (!formGroup || !formGroup.controls) {
      return;
    }
    
    Object.keys(formGroup.controls).forEach(key => {
      const control = formGroup.get(key);
      if (control instanceof FormGroup) {
        this.markFormGroupTouched(control);
      } else {
        control?.markAsTouched();
      }
    });
  }

  private showValidationErrors() {
    const errors: string[] = [];
    
    if (this.ratingForm?.get('evaluatedUserId')?.errors) {
      errors.push('Veuillez s√©lectionner un utilisateur √† √©valuer');
    }
    
    if (this.ratingForm?.get('type')?.errors) {
      errors.push('Veuillez s√©lectionner le type d\'√©valuation');
    }
    
    if (this.ratingForm?.get('comment')?.errors) {
      const commentErrors = this.ratingForm.get('comment')?.errors;
      if (commentErrors?.['required']) {
        errors.push('Le commentaire est obligatoire');
      }
      if (commentErrors?.['minlength']) {
        errors.push('Le commentaire doit contenir au moins 10 caract√®res');
      }
      if (commentErrors?.['maxlength']) {
        errors.push('Le commentaire ne peut pas d√©passer 1000 caract√®res');
      }
    }
    
    if (this.ratingForm?.errors?.['dateRange']) {
      errors.push(this.ratingForm.errors['dateRange']);
    }
    
    if (this.ratingForm?.get('score')?.errors?.['scoreInconsistency']) {
      errors.push(this.ratingForm.get('score')?.errors!['scoreInconsistency']);
    }
    
    if (errors.length > 0) {
      this.showErrorMessage(errors.join('\n'));
    }
  }

  // üìã PR√âPARATION DES DONN√âES
  private prepareCreateData(): CreateRatingDto {
    if (!this.ratingForm) {
      throw new Error('Formulaire non initialis√©');
    }
    
    const formValue = this.ratingForm.value;
    
    const baseData = {
      evaluatedUserId: Number(formValue.evaluatedUserId),
      score: Number(formValue.score),
      comment: formValue.comment?.trim() || '',
      type: Number(formValue.type),
      evaluationPeriodStart: formValue.evaluationPeriodStart ? new Date(formValue.evaluationPeriodStart) : undefined,
      evaluationPeriodEnd: formValue.evaluationPeriodEnd ? new Date(formValue.evaluationPeriodEnd) : undefined,
      stageReference: formValue.stageReference?.trim() || undefined
    };

    if (this.isEvaluatingTutor()) {
      return {
        ...baseData,
        tutorScores: formValue.tutorScores
      } as CreateRatingDto;
    } else {
      return {
        ...baseData,
        detailedScores: formValue.detailedScores
      } as CreateRatingDto;
    }
  }

  private prepareUpdateData(): UpdateRatingDto {
    if (!this.ratingForm) {
      throw new Error('Formulaire non initialis√©');
    }
    
    const formValue = this.ratingForm.value;
    
    const baseData = {
      score: Number(formValue.score),
      comment: formValue.comment?.trim() || '',
      evaluationPeriodStart: formValue.evaluationPeriodStart ? new Date(formValue.evaluationPeriodStart) : undefined,
      evaluationPeriodEnd: formValue.evaluationPeriodEnd ? new Date(formValue.evaluationPeriodEnd) : undefined,
      stageReference: formValue.stageReference?.trim() || undefined
    };

    if (this.isEvaluatingTutor()) {
      return {
        ...baseData,
        tutorScores: formValue.tutorScores
      } as UpdateRatingDto;
    } else {
      return {
        ...baseData,
        detailedScores: formValue.detailedScores
      } as UpdateRatingDto;
    }
  }

  // üß≠ NAVIGATION
  goBack() {
    if (this.hasUnsavedChanges()) {
      const confirmLeave = confirm('Vous avez des modifications non sauvegard√©es. Voulez-vous vraiment quitter ?');
      if (!confirmLeave) {
        return;
      }
    }

    if (window.history.length > 1) {
      window.history.back();
    } else {
      this.router.navigate(['/ratings']);
    }
  }

  // üí¨ NOTIFICATIONS
  private showSuccessMessage(message: string) {
    console.log('‚úÖ Succ√®s:', message);
    // Int√©gration avec votre service de notification
    // this.notificationService.success(message);
  }

  private showErrorMessage(message: string) {
    console.error('‚ùå Erreur:', message);
    // Int√©gration avec votre service de notification
    // this.notificationService.error(message);
  }

  // üîß M√âTHODES MANQUANTES AJOUT√âES

  // üé® M√©thode getAnimationDelay (utilis√©e dans le template)
  getAnimationDelay(index: number): string {
    return `${index * 0.1}s`;
  }

  // üîß M√©thodes TrackBy pour les *ngFor (performance)
  trackByValue(index: number, item: any): any {
    return item?.value || index;
  }

  trackByUserId(index: number, user: any): any {
    return user?.id || index;
  }

  trackByCriterionKey(index: number, criterion: any): any {
    return criterion?.key || index;
  }

  // üß™ M√âTHODES DE DEBUG AM√âLIOR√âES
  testFormFunctionality() {
    console.group('üß™ Test du formulaire d\'√©valuation - DIAGNOSTIC COMPLET');
    
    console.log('üìã Statut du formulaire:');
    console.log('- Valide:', this.ratingForm?.valid);
    console.log('- Modifi√©:', this.ratingForm?.dirty);
    console.log('- Touch√©:', this.ratingForm?.touched);
    console.log('- Changements non sauvegard√©s:', this.hasUnsavedChanges());
    
    console.log('üìä Valeurs critiques:');
    const typeValue = this.ratingForm?.get('type')?.value;
    console.log('- Type value:', typeValue, typeof typeValue);
    console.log('- Type signal:', this.typeFormValueSignal());
    console.log('- showDetailedCriteria():', this.showDetailedCriteria());
    console.log('- isEvaluatingTutor():', this.isEvaluatingTutor());
    
    console.log('üë• Donn√©es utilisateurs:');
    console.log('- Utilisateur connect√©:', this.currentUser());
    console.log('- Types disponibles:', this.availableTypes());
    console.log('- Utilisateurs √©valuables:', this.availableUsers());
    
    console.log('üéØ Enum EvaluationType:');
    console.log('- TuteurToStagiaire:', EvaluationType.TuteurToStagiaire);
    console.log('- RHToStagiaire:', EvaluationType.RHToStagiaire);
    console.log('- StagiaireToTuteur:', EvaluationType.StagiaireToTuteur);
    
    console.log('üîß Form Controls:');
    console.log('- type control:', this.ratingForm?.get('type'));
    console.log('- type errors:', this.ratingForm?.get('type')?.errors);
    
    console.groupEnd();
    
    // üîß Test automatique des types
    console.log('üß™ Test automatique changement vers TuteurToStagiaire...');
    this.ratingForm?.get('type')?.setValue(EvaluationType.TuteurToStagiaire);
    this.onEvaluationTypeChange();
    
    setTimeout(() => {
      console.log('üß™ Apr√®s test TuteurToStagiaire:');
      console.log('- showDetailedCriteria():', this.showDetailedCriteria());
      console.log('- isEvaluatingTutor():', this.isEvaluatingTutor());
    }, 100);
  }

  private logFormErrors(form: FormGroup, prefix: string = '') {
    if (!form || !form.controls) {
      return;
    }
    
    Object.keys(form.controls).forEach(key => {
      const control = form.get(key);
      const fullKey = prefix ? `${prefix}.${key}` : key;
      
      if (control instanceof FormGroup) {
        this.logFormErrors(control, fullKey);
      } else if (control?.errors) {
        console.log(`  - ${fullKey}:`, control.errors);
      }
    });
  }

  // üîí GUARD CONTRE LA FERMETURE SANS SAUVEGARDE
  canDeactivate(): boolean {
    if (this.hasUnsavedChanges()) {
      return confirm('Vous avez des modifications non sauvegard√©es. Voulez-vous vraiment quitter ?');
    }
    return true;
  }

  // üìä M√©thodes pour r√©cup√©rer les valeurs des crit√®res
 getTutorCriterionValue(criterionKey: string): number {
  const tutorScoresGroup = this.ratingForm?.get('tutorScores') as FormGroup;
  return tutorScoresGroup?.get(criterionKey)?.value || 3;
}

  getDetailedCriterionValue(criterionKey: string): number {
  const detailedScoresGroup = this.ratingForm?.get('detailedScores') as FormGroup;
  return detailedScoresGroup?.get(criterionKey)?.value || 3;
}

  // üìù Descriptions des crit√®res
  getTutorCriterionDescription(key: string): string {
    const criterion = this.tutorCriteria.find(c => c.key === key);
    return criterion?.description || '';
  }

  getDetailedCriterionDescription(key: string): string {
    const criterion = this.detailedCriteria.find(c => c.key === key);
    return criterion?.description || '';
  }

  // üé® Couleurs des scores
  getScoreColor(score: number): string {
    if (score <= 2) return 'score-low';
    if (score <= 3.5) return 'score-medium';
    return 'score-high';
  }

  // ‚ú® Accepter le score sugg√©r√©
  acceptSuggestedScore() {
    this.ratingForm?.get('score')?.setValue(this.suggestedGeneralScore());
    console.log('‚úÖ Score sugg√©r√© accept√©:', this.suggestedGeneralScore());
  }

  isSuggestedScoreActive(): boolean {
    const currentScore = this.ratingForm?.get('score')?.value || 0;
    const suggestedScore = this.suggestedGeneralScore();
    return Math.abs(currentScore - suggestedScore) < 0.1;
  }
  /**
 * üîÑ Actualiser la liste des utilisateurs disponibles
 */
refreshAvailableUsers() {
  console.log('üîÑ Actualisation manuelle de la liste des utilisateurs...');
  this.isLoading.set(true);
  
  // Vider la liste actuelle
  this.availableUsers.set([]);
  
  // Recharger les utilisateurs
  this.loadAvailableUsers();
}

/**
 * üéØ V√©rifier si un utilisateur peut √™tre √©valu√©
 */
canEvaluateUser(userId: number): boolean {
  return this.availableUsers().some(user => user.id === userId);
}

/**
 * üìä Obtenir le nombre d'utilisateurs disponibles par r√¥le
 */
getAvailableUsersCountByRole(): { [role: string]: number } {
  const users = this.availableUsers();
  const countByRole: { [role: string]: number } = {};
  
  users.forEach(user => {
    const role = user.role || 'Non d√©fini';
    countByRole[role] = (countByRole[role] || 0) + 1;
  });
  
  return countByRole;
}

/**
 * üîç Rechercher un utilisateur dans la liste disponible
 */
findAvailableUserById(userId: number): any | null {
  return this.availableUsers().find(user => user.id === userId) || null;
}

/**
 * üé® Obtenir le message personnalis√© selon le contexte
 */
getNoUsersMessage(): string {
  const user = this.currentUser();
  const selectedType = this.ratingForm?.get('type')?.value;
  
  if (!user) return 'Aucun utilisateur disponible.';
  
  if (selectedType === EvaluationType.TuteurToStagiaire) {
    return 'Vous avez d√©j√† √©valu√© tous vos stagiaires assign√©s, ou aucun stagiaire ne vous est actuellement assign√©.';
  } else if (selectedType === EvaluationType.StagiaireToTuteur) {
    return 'Vous avez d√©j√† √©valu√© votre tuteur, ou aucun tuteur ne vous est assign√©.';
  } else if (selectedType === EvaluationType.RHToStagiaire) {
    return 'Vous avez d√©j√† √©valu√© tous les stagiaires, ou aucun stagiaire n\'est disponible.';
  }
  
  return 'Vous avez d√©j√† √©valu√© tous les utilisateurs que vous pouvez √©valuer.';
}

/**
 * üéØ V√©rifier si l'utilisateur a des √©valuations en attente
 */
hasAvailableUsersForCurrentType(): boolean {
  const selectedType = this.ratingForm?.get('type')?.value;
  if (!selectedType && selectedType !== 0) return false;
  
  return this.availableUsers().length > 0;
}

/**
 * üîß Handler pour le changement de type d'√©valuation - VERSION AM√âLIOR√âE
 */
onEvaluationTypeChangeImproved() {
  const type = this.ratingForm.get('type')?.value;
  console.log('üîÑ Type d\'√©valuation chang√©:', type, typeof type);
  
  // Mettre √† jour le signal de bridge
  this.typeFormValueSignal.set(type);
  
  // R√©initialiser l'utilisateur s√©lectionn√© car la liste va changer
  this.ratingForm.get('evaluatedUserId')?.setValue('');
  
  // Recharger la liste des utilisateurs pour ce type d'√©valuation
  if (type !== '' && type !== undefined && type !== null) {
    this.refreshAvailableUsers();
  }
  
  this.resetScores();
  this.updateSuggestedScore();
  
  // Forcer la mise √† jour des computed properties
  setTimeout(() => {
    console.log('üîÑ Apr√®s onEvaluationTypeChange:');
    console.log('- showDetailedCriteria():', this.showDetailedCriteria());
    console.log('- isEvaluatingTutor():', this.isEvaluatingTutor());
    console.log('- Utilisateurs disponibles:', this.availableUsers().length);
  }, 0);
}






/**
 * üîç FILTRAGE PRINCIPAL: Filtre les utilisateurs selon les crit√®res de recherche
 */
filterAvailableUsers() {
  console.log('üîç === D√âBUT FILTRAGE UTILISATEURS √âVALUABLES ===');
  console.log('üìù Texte de recherche:', `"${this.userSearchText}"`);
  console.log('üè¢ D√©partement:', `"${this.userDepartmentFilter}"`);
  console.log('üé≠ R√¥le:', `"${this.userRoleFilter}"`);
  console.log('üë• Utilisateurs de base:', this.availableUsers().length);
  
  let filtered = [...this.availableUsers()];
  console.log('üîÑ Utilisateurs apr√®s copie:', filtered.length);
  
  // üîç Filtre par texte de recherche (nom, pr√©nom, username, email)
  if (this.userSearchText.trim()) {
    const searchLower = this.userSearchText.toLowerCase().trim();
    console.log('üîç Recherche active avec:', `"${searchLower}"`);
    
    const beforeSearchFilter = filtered.length;
    filtered = filtered.filter(user => {
      const firstName = (user.firstName || '').toLowerCase();
      const lastName = (user.lastName || '').toLowerCase();
      const username = (user.username || '').toLowerCase();
      const email = (user.email || '').toLowerCase();
      const fullName = `${firstName} ${lastName}`.trim();
      
      const matches = firstName.includes(searchLower) ||
                     lastName.includes(searchLower) ||
                     fullName.includes(searchLower) ||
                     username.includes(searchLower) ||
                     email.includes(searchLower);
      
      console.log(`   üë§ ${user.firstName} ${user.lastName}: firstName="${firstName}", lastName="${lastName}", fullName="${fullName}", matches=${matches}`);
      
      return matches;
    });
    console.log(`üîç Apr√®s filtre texte: ${beforeSearchFilter} ‚Üí ${filtered.length}`);
  }
  
  // üè¢ Filtre par d√©partement
  if (this.userDepartmentFilter) {
    console.log('üè¢ Filtre d√©partement actif avec:', `"${this.userDepartmentFilter}"`);
    
    const beforeDeptFilter = filtered.length;
    filtered = filtered.filter(user => {
      const userDepartment = user.department || user.departement || '';
      const matches = userDepartment.toLowerCase() === this.userDepartmentFilter.toLowerCase();
      
      console.log(`   üë§ ${user.firstName} ${user.lastName}: d√©partement="${userDepartment}", filtre="${this.userDepartmentFilter}", matches=${matches}`);
      
      return matches;
    });
    console.log(`üè¢ Apr√®s filtre d√©partement: ${beforeDeptFilter} ‚Üí ${filtered.length}`);
  }
  
  // üé≠ Filtre par r√¥le
  if (this.userRoleFilter) {
    console.log('üé≠ Filtre de r√¥le actif avec:', `"${this.userRoleFilter}"`);
    
    const beforeRoleFilter = filtered.length;
    filtered = filtered.filter(user => {
      const userRole = user.role || '';
      const matches = userRole.toLowerCase() === this.userRoleFilter.toLowerCase();
      
      console.log(`   üë§ ${user.firstName} ${user.lastName}: r√¥le="${userRole}", filtre="${this.userRoleFilter}", matches=${matches}`);
      
      return matches;
    });
    console.log(`üé≠ Apr√®s filtre r√¥le: ${beforeRoleFilter} ‚Üí ${filtered.length}`);
  }
  
  this.filteredAvailableUsers.set(filtered);
  console.log(`‚úÖ R√âSULTAT FINAL: ${filtered.length} utilisateur(s) filtr√©s sur ${this.availableUsers().length} total`);
  console.log('üîç === FIN FILTRAGE UTILISATEURS √âVALUABLES ===');
}

/**
 * üîç √âV√âNEMENT: Appel√© quand le texte de recherche change
 */
onUserSearchChange() {
  console.log('üîç onUserSearchChange appel√©, nouveau texte:', `"${this.userSearchText}"`);
  this.filterAvailableUsers();
}

/**
 * üè¢ √âV√âNEMENT: Appel√© quand le filtre de d√©partement change
 */
onUserDepartmentFilterChange() {
  console.log('üè¢ onUserDepartmentFilterChange appel√©, nouveau d√©partement:', `"${this.userDepartmentFilter}"`);
  this.filterAvailableUsers();
}

/**
 * üé≠ √âV√âNEMENT: Appel√© quand le filtre de r√¥le change
 */
onUserRoleFilterChange() {
  console.log('üé≠ onUserRoleFilterChange appel√©, nouveau r√¥le:', `"${this.userRoleFilter}"`);
  this.filterAvailableUsers();
}

/**
 * üßπ RESET: Remet √† z√©ro tous les filtres utilisateurs
 */
resetUserFilters() {
  console.log('üßπ Reset des filtres utilisateurs');
  this.userSearchText = '';
  this.userDepartmentFilter = '';
  this.userRoleFilter = '';
  this.filteredAvailableUsers.set([...this.availableUsers()]);
  console.log(`‚úÖ Filtres remis √† z√©ro, ${this.filteredAvailableUsers().length} utilisateurs affich√©s`);
}

/**
 * üîß NOUVEAU: Validation intelligente des filtres apr√®s changement de donn√©es
 */
private validateAndCleanFilters() {
  console.log('üîç Validation des filtres apr√®s changement de donn√©es...');
  
  let hasChanged = false;
  
  // V√©rifier si le d√©partement filtr√© existe encore
  if (this.userDepartmentFilter) {
    const availableDepts = this.getAvailableDepartments();
    if (!availableDepts.includes(this.userDepartmentFilter)) {
      console.log(`‚ö†Ô∏è D√©partement filtr√© "${this.userDepartmentFilter}" n'existe plus, reset...`);
      this.userDepartmentFilter = '';
      hasChanged = true;
    }
  }
  
  // V√©rifier si le r√¥le filtr√© existe encore
  if (this.userRoleFilter) {
    const availableRoles = this.getAvailableUserRoles();
    if (!availableRoles.includes(this.userRoleFilter)) {
      console.log(`‚ö†Ô∏è R√¥le filtr√© "${this.userRoleFilter}" n'existe plus, reset...`);
      this.userRoleFilter = '';
      hasChanged = true;
    }
  }
  
  // Si des filtres ont √©t√© nettoy√©s, relancer le filtrage
  if (hasChanged) {
    console.log('üîÑ Filtres nettoy√©s, relance du filtrage...');
    this.filterAvailableUsers();
  }
  
  return hasChanged;
}

/**
 * üìä Obtenir des statistiques d√©taill√©es sur les filtres
 */
getFilterStatistics(): any {
  const stats = {
    total: this.availableUsers().length,
    filtered: this.filteredAvailableUsers().length,
    activeFilters: {
      search: !!this.userSearchText.trim(),
      department: !!this.userDepartmentFilter,
      role: !!this.userRoleFilter
    },
    availableOptions: {
      departments: this.getAvailableDepartments(),
      roles: this.getAvailableUserRoles()
    },
    distribution: {
      byDepartment: this.getUserCountByDepartment(),
      byRole: this.getUserCountByRole()
    }
  };
  
  console.log('üìä Statistiques des filtres:', stats);
  return stats;
}

/**
 * üìä Obtenir la liste des d√©partements pr√©sents dans les utilisateurs disponibles - VERSION DYNAMIQUE
 */
getAvailableDepartments(): string[] {
  console.log('üè¢ Extraction des d√©partements dynamiques...');
  
  const departments = new Set<string>();
  
  this.availableUsers().forEach(user => {
    // üîß V√©rifier toutes les propri√©t√©s possibles pour le d√©partement
    const dept = user.department || user.departement || user.Department || user.dept;
    
    if (dept && typeof dept === 'string' && dept.trim()) {
      const cleanDept = dept.trim();
      departments.add(cleanDept);
      console.log(`   ‚Üí D√©partement trouv√©: "${cleanDept}" (utilisateur: ${user.firstName} ${user.lastName})`);
    }
  });
  
  const departmentList = Array.from(departments).sort();
  console.log(`üè¢ ${departmentList.length} d√©partement(s) dynamique(s) d√©tect√©(s):`, departmentList);
  
  return departmentList;
}

/**
 * üìä Obtenir la liste des r√¥les pr√©sents dans les utilisateurs disponibles - VERSION DYNAMIQUE
 */
getAvailableUserRoles(): string[] {
  console.log('üé≠ Extraction des r√¥les dynamiques...');
  
  const roles = new Set<string>();
  
  this.availableUsers().forEach(user => {
    if (user.role) {
      const role = typeof user.role === 'string' ? user.role : user.role.toString();
      if (role.trim()) {
        roles.add(role.trim());
        console.log(`   ‚Üí R√¥le trouv√©: "${role}" (utilisateur: ${user.firstName} ${user.lastName})`);
      }
    }
  });
  
  const roleList = Array.from(roles).sort();
  console.log(`üé≠ ${roleList.length} r√¥le(s) dynamique(s) d√©tect√©(s):`, roleList);
  
  return roleList;
}

/**
 * üî¢ Obtenir le nombre d'utilisateurs par d√©partement
 */
getUserCountByDepartment(): { [department: string]: number } {
  const counts: { [department: string]: number } = {};
  
  this.filteredAvailableUsers().forEach(user => {
    const dept = user.department || user.departement || 'Non d√©fini';
    counts[dept] = (counts[dept] || 0) + 1;
  });
  
  return counts;
}

/**
 * üî¢ Obtenir le nombre d'utilisateurs par r√¥le
 */
getUserCountByRole(): { [role: string]: number } {
  const counts: { [role: string]: number } = {};
  
  this.filteredAvailableUsers().forEach(user => {
    const role = user.role || 'Non d√©fini';
    counts[role] = (counts[role] || 0) + 1;
  });
  
  return counts;
}



}