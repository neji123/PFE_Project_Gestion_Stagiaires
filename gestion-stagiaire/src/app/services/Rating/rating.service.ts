import { Injectable, Inject, PLATFORM_ID } from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams, HttpErrorResponse } from '@angular/common/http';
import { Observable, BehaviorSubject, throwError, of, forkJoin, timer } from 'rxjs';
import { tap, catchError, map, switchMap, retry, finalize, shareReplay } from 'rxjs/operators';
import { isPlatformBrowser } from '@angular/common';
import { environment } from '../../environments/environment';

// üìù Types et interfaces
export enum EvaluationType {
  TuteurToStagiaire = 0,
  RHToStagiaire = 1,
  StagiaireToTuteur = 2
}

export enum RatingStatus {
  Draft = 0,
  Submitted = 1,
  Approved = 2,
  Rejected = 3
}

export interface CreateRatingDto {
  evaluatedUserId: number;
  score: number;
  comment: string;
  type: EvaluationType;
  detailedScores?: DetailedEvaluationCriteria;
  tutorScores?: TutorEvaluationCriteria;
  evaluationPeriodStart?: Date;
  evaluationPeriodEnd?: Date;
  stageReference?: string;
}

export interface UpdateRatingDto {
  score?: number;
  comment?: string;
  detailedScores?: DetailedEvaluationCriteria;
  tutorScores?: TutorEvaluationCriteria;
  evaluationPeriodStart?: Date;
  evaluationPeriodEnd?: Date;
  stageReference?: string;
}

export interface RatingDetailDto {
  id: number;
  evaluatorId: number;
  evaluatorName: string;
  evaluatorRole: string;
  evaluatorProfilePicture?: string;
  evaluatedUserId: number;
  evaluatedUserName: string;
  evaluatedUserRole: string;
  evaluatedUserProfilePicture?: string;
  score: number;
  comment: string;
  type: EvaluationType;
  status: RatingStatus;
  detailedScores?: DetailedEvaluationCriteria;
  tutorScores?: TutorEvaluationCriteria;
  createdAt: Date;
  updatedAt?: Date;
  submittedAt?: Date;
  approvedAt?: Date;
  approvedByUserId?: number;
  approvedByUserName?: string;
  response?: string;
  responseDate?: Date;
  evaluationPeriodStart?: Date;
  evaluationPeriodEnd?: Date;
  stageReference?: string;
}

export interface RatingListDto {
  id: number;
  evaluatorName: string;
   evaluatedUserId: number; 
  evaluatedUserName: string;
  score: number;
  type: EvaluationType;
  status: RatingStatus;
  createdAt: Date;
  submittedAt?: Date;
  stageReference?: string;
}

export interface RatingFilterDto {
  evaluatorId?: number;
  evaluatedUserId?: number;
  type?: EvaluationType;
  status?: RatingStatus;
  fromDate?: Date;
  toDate?: Date;
  minScore?: number;
  maxScore?: number;
  stageReference?: string;
  pageNumber?: number;
  pageSize?: number;
  sortBy?: string;
  sortDescending?: boolean;
}

export interface PagedRatingResultDto {
  ratings: RatingListDto[];
  totalCount: number;
  pageNumber: number;
  pageSize: number;
  hasNextPage: boolean;
  hasPreviousPage: boolean;
}

export interface RatingStatsDto {
  totalRatings: number;
  averageScoreGiven: number;
  averageScore: number;
  pendingRatings: number;
  approvedRatings: number;
  draftRatings: number;
  scoreDistribution: { [key: number]: number };
  statsByType: { [key: string]: RatingTypeStats };
  specialStats?: { [key: string]: any };
}

export interface RatingTypeStats {
  count: number;
  averageScore: number;
  lastRatingDate?: Date;
}

export interface DetailedEvaluationCriteria {
  technicalSkills: number;
  communication: number;
  teamwork: number;
  initiative: number;
  punctuality: number;
  problemSolving: number;
  adaptability: number;
  overallPerformance: number;
}

export interface TutorEvaluationCriteria {
  availability: number;
  guidance: number;
  communication: number;
  expertise: number;
  support: number;
  feedback: number;
  overallSatisfaction: number;
}

export interface RatingResponseDto {
  ratingId: number;
  response: string;
}

export interface ApproveRatingDto {
  ratingId: number;
  isApproved: boolean;
  approvalComment?: string;
}
export interface BestStagiaireStats {
  name: string;
  score: number;
  evaluationDate: Date;
}

export interface TopUserStats {
  userId: number;
  name: string;
  averageScore: number;
  evaluationCount: number;
}

export interface SpecialStatsData {
  bestStagiaire?: BestStagiaireStats;
  topTutors?: TopUserStats[];
  topStagiaires?: TopUserStats[];
}


@Injectable({
  providedIn: 'root'
})
export class RatingService {
  private apiUrl = `${environment.apiUrl}/api/rating`;
  private isBrowser: boolean;

  // üîÑ √âtat r√©actif
  private _myRatings$ = new BehaviorSubject<RatingListDto[]>([]);
  private _ratingsAboutMe$ = new BehaviorSubject<RatingListDto[]>([]);
  private _pendingApprovals$ = new BehaviorSubject<RatingListDto[]>([]);
  private _draftRatings$ = new BehaviorSubject<RatingListDto[]>([]);
  private _userStats$ = new BehaviorSubject<RatingStatsDto | null>(null);

  // üìä Observables publics
  public myRatings$ = this._myRatings$.asObservable();
  public ratingsAboutMe$ = this._ratingsAboutMe$.asObservable();
  public pendingApprovals$ = this._pendingApprovals$.asObservable();
  public draftRatings$ = this._draftRatings$.asObservable();
  public userStats$ = this._userStats$.asObservable();

  constructor(
    private http: HttpClient,
    @Inject(PLATFORM_ID) private platformId: any
  ) {
    this.isBrowser = isPlatformBrowser(this.platformId);
  }

  // üîê Headers avec authentification
  private getHeaders(): HttpHeaders {
    let headers = new HttpHeaders().set('Content-Type', 'application/json');
    if (this.isBrowser) {
      const token = localStorage.getItem('auth_token');
      if (token) {
        headers = headers.set('Authorization', `Bearer ${token}`);
      }
    }
    return headers;
  }

  // üîÑ Gestion des erreurs
  private handleError(error: any, context?: string) {
    console.error(`üö´ Erreur Rating Service${context ? ` (${context})` : ''}:`, error);
    
    let errorMessage = 'Une erreur est survenue';
    
    if (error instanceof HttpErrorResponse) {
      switch (error.status) {
        case 400:
          errorMessage = 'Donn√©es invalides. Veuillez v√©rifier votre saisie.';
          break;
        case 401:
          errorMessage = 'Vous n\'√™tes pas authentifi√©. Veuillez vous reconnecter.';
          break;
        case 403:
          errorMessage = 'Vous n\'avez pas les permissions pour cette action.';
          break;
        case 404:
          errorMessage = '√âvaluation non trouv√©e.';
          break;
        case 409:
          errorMessage = 'Une √©valuation existe d√©j√† pour cet utilisateur.';
          break;
        case 500:
          errorMessage = 'Erreur serveur. Veuillez r√©essayer plus tard.';
          break;
        default:
          errorMessage = `Erreur ${error.status}: ${error.statusText || 'Erreur inconnue'}`;
      }
    } else if (error.error?.message) {
      errorMessage = error.error.message;
    } else if (error.message) {
      errorMessage = error.message;
    }
    
    return throwError(() => new Error(errorMessage));
  }

  // üìù CRUD Operations

  /**
 * ‚ûï Cr√©er une nouvelle √©valuation
 */
createRating(createRatingDto: CreateRatingDto): Observable<RatingDetailDto> {
  console.log('üÜï Cr√©ation d\'une nouvelle √©valuation:', createRatingDto);
  
  return this.http.post<RatingDetailDto>(this.apiUrl, createRatingDto, { 
    headers: this.getHeaders() 
  }).pipe(
    tap(response => {
      console.log('‚úÖ √âvaluation cr√©√©e avec succ√®s:', response);
      // üîß Attendre un peu avant de refresh pour √©viter les conflits
      timer(500).subscribe(() => this.refreshData());
    }),
    catchError(error => this.handleError(error, 'createRating'))
  );
}

/**
 * ‚úèÔ∏è Mettre √† jour une √©valuation
 */
updateRating(id: number, updateRatingDto: UpdateRatingDto): Observable<RatingDetailDto> {
  console.log(`üìù Mise √† jour de l'√©valuation ${id}:`, updateRatingDto);
  
  return this.http.put<RatingDetailDto>(`${this.apiUrl}/${id}`, updateRatingDto, {
    headers: this.getHeaders()
  }).pipe(
    tap(response => {
      console.log('‚úÖ √âvaluation mise √† jour:', response);
      // üîß Attendre un peu avant de refresh
      timer(500).subscribe(() => this.refreshData());
    }),
    catchError(error => this.handleError(error, 'updateRating'))
  );
}

  /**
   * üëÅÔ∏è R√©cup√©rer une √©valuation par ID
   */
  getRatingById(id: number): Observable<RatingDetailDto> {
  console.log('üîç Service: R√©cup√©ration √©valuation ID:', id);
  
  return this.http.get<RatingDetailDto>(`${this.apiUrl}/${id}`, {
    headers: this.getHeaders()
  }).pipe(
    tap(rating => {
      console.log('‚úÖ Service: √âvaluation re√ßue:', rating);
      console.log('üìä Detailed Scores:', rating.detailedScores);
      console.log('üë®‚Äçüè´ Tutor Scores:', rating.tutorScores);
      console.log('üéØ Type:', rating.type);
      
      // Validation des donn√©es
      if (rating.type === EvaluationType.StagiaireToTuteur && !rating.tutorScores) {
        console.warn('‚ö†Ô∏è √âvaluation tuteur sans crit√®res tuteur!');
      }
      if (rating.type !== EvaluationType.StagiaireToTuteur && !rating.detailedScores) {
        console.warn('‚ö†Ô∏è √âvaluation standard sans crit√®res d√©taill√©s!');
      }
    }),
    catchError(error => this.handleError(error, 'getRatingById'))
  );
}

  /**
   * üóëÔ∏è Supprimer une √©valuation
   */
  deleteRating(id: number): Observable<boolean> {
    return this.http.delete<any>(`${this.apiUrl}/${id}`, {
      headers: this.getHeaders()
    }).pipe(
      map(() => true),
      tap(() => {
        console.log(`üóëÔ∏è √âvaluation ${id} supprim√©e`);
        this.refreshData();
      }),
      catchError(error => {
        console.error('Erreur lors de la suppression:', error);
        return of(false);
      })
    );
  }

  /**
   * üì§ Soumettre une √©valuation pour approbation
   */
  submitRating(id: number): Observable<RatingDetailDto> {
    return this.http.post<RatingDetailDto>(`${this.apiUrl}/${id}/submit`, {}, {
      headers: this.getHeaders()
    }).pipe(
      tap(response => {
        console.log(`üì§ √âvaluation ${id} soumise pour approbation`);
        this.refreshData();
      }),
      catchError(error => this.handleError(error, 'submitRating'))
    );
  }

  /**
   * üìù R√©cup√©rer mes √©valuations
   */
  getMyRatings(type?: EvaluationType, forceRefresh = false): Observable<RatingListDto[]> {
    if (!forceRefresh && this._myRatings$.value.length > 0) {
      return this.myRatings$;
    }

    let params = new HttpParams();
    if (type !== undefined) {
      params = params.set('type', type.toString());
    }

    return this.http.get<RatingListDto[]>(`${this.apiUrl}/my-ratings`, {
      headers: this.getHeaders(),
      params: params
    }).pipe(
      tap(ratings => {
        console.log('üìù Mes √©valuations r√©cup√©r√©es:', ratings.length);
        this._myRatings$.next(ratings);
      }),
      catchError(error => this.handleError(error, 'getMyRatings'))
    );
  }

  /**
   * üëÅÔ∏è R√©cup√©rer les √©valuations me concernant
   */
  getRatingsAboutMe(forceRefresh = false): Observable<RatingListDto[]> {
    if (!forceRefresh && this._ratingsAboutMe$.value.length > 0) {
      return this.ratingsAboutMe$;
    }

    return this.http.get<RatingListDto[]>(`${this.apiUrl}/about-me`, {
      headers: this.getHeaders()
    }).pipe(
      tap(ratings => {
        console.log('üëÅÔ∏è √âvaluations me concernant r√©cup√©r√©es:', ratings.length);
        this._ratingsAboutMe$.next(ratings);
      }),
      catchError(error => this.handleError(error, 'getRatingsAboutMe'))
    );
  }

  /**
   * üìÑ R√©cup√©rer mes brouillons
   */
  getDraftRatings(forceRefresh = false): Observable<RatingListDto[]> {
    if (!forceRefresh && this._draftRatings$.value.length > 0) {
      return this.draftRatings$;
    }

    return this.http.get<RatingListDto[]>(`${this.apiUrl}/drafts`, {
      headers: this.getHeaders()
    }).pipe(
      tap(ratings => {
        console.log('üìÑ Brouillons r√©cup√©r√©s:', ratings.length);
        this._draftRatings$.next(ratings);
      }),
      catchError(error => this.handleError(error, 'getDraftRatings'))
    );
  }

  /**
   * üë• R√©cup√©rer les utilisateurs que je peux √©valuer
   */
  getUsersICanRate(): Observable<any[]> {
    return this.http.get<any[]>(`${this.apiUrl}/users-i-can-rate`, {
      headers: this.getHeaders()
    }).pipe(
      catchError(error => {
        console.error('Erreur r√©cup√©ration utilisateurs √©valuables:', error);
        return of([]);
      })
    );
  }

  /**
 * üìà R√©cup√©rer mes statistiques d'√©valuation - VERSION S√âCURIS√âE
 */
getMyRatingStats(forceRefresh = false): Observable<RatingStatsDto | null> {
  if (!forceRefresh && this._userStats$.value) {
    return this.userStats$.pipe(map(stats => stats));
  }

  return this.http.get<RatingStatsDto>(`${this.apiUrl}/stats/me`, {
    headers: this.getHeaders()
  }).pipe(
    tap(stats => {
      console.log('üìà Mes statistiques r√©cup√©r√©es:', stats);
      this._userStats$.next(stats);
    }),
    catchError(error => {
      console.warn('‚ö†Ô∏è Statistiques non disponibles (continuant sans elles):', error);
      // üîß NE PAS FAIRE √âCHOUER - retourner null
      this._userStats$.next(null);
      return of(null);
    })
  );
}

 /**
 * üîÑ Actualiser toutes les donn√©es - VERSION S√âCURIS√âE
 */
refreshData(): void {
  // üîß Protection contre les appels multiples
  if (this._isRefreshing) {
    console.log('üö´ Refresh d√©j√† en cours, ignor√©');
    return;
  }

  this._isRefreshing = true;
  console.log('üîÑ Actualisation des donn√©es Rating...');
  
  // üîß Charger seulement les donn√©es critiques d'abord
  const criticalOperations = [
    this.getMyRatings(undefined, true),
    this.getRatingsAboutMe(true),
    this.getDraftRatings(true)
  ];

  // üîß Charger les stats de mani√®re optionnelle
  const optionalOperations = [
    this.getMyRatingStats(true).pipe(
      catchError(error => {
        console.warn('‚ö†Ô∏è Stats non disponibles (non-critique):', error);
        return of(null); // Ne pas faire √©chouer
      })
    )
  ];

  // Ex√©cuter les op√©rations critiques
  forkJoin(criticalOperations).pipe(
    finalize(() => {
      this._isRefreshing = false;
    })
  ).subscribe({
    next: () => {
      console.log('‚úÖ Donn√©es critiques charg√©es');
      // Charger les stats en arri√®re-plan (optionnel)
      optionalOperations[0].subscribe();
    },
    error: (error) => {
      console.error('‚ùå Erreur lors du chargement des donn√©es critiques:', error);
    }
  });
}
private _isRefreshing = false;


  /**
   * üßπ Nettoyer le cache
   */
  clearCache(): void {
    console.log('üßπ Nettoyage du cache Rating');
    this._myRatings$.next([]);
    this._ratingsAboutMe$.next([]);
    this._pendingApprovals$.next([]);
    this._draftRatings$.next([]);
    this._userStats$.next(null);
  }

  // üé® M√©thodes d'aide pour l'interface

  /**
   * üé® Obtenir la couleur selon le score
   */
  getScoreColor(score: number): string {
    if (score >= 4.5) return 'text-green-600';
    if (score >= 3.5) return 'text-blue-600';
    if (score >= 2.5) return 'text-yellow-600';
    return 'text-red-600';
  }

  /**
   * üè∑Ô∏è Obtenir le badge de statut
   */
  getStatusBadge(status: RatingStatus): { class: string; text: string } {
    switch (status) {
      case RatingStatus.Draft:
        return { class: 'bg-gray-100 text-gray-800', text: 'Brouillon' };
      case RatingStatus.Submitted:
        return { class: 'bg-blue-100 text-blue-800', text: 'Soumis' };
      case RatingStatus.Approved:
        return { class: 'bg-green-100 text-green-800', text: 'Approuv√©' };
      case RatingStatus.Rejected:
        return { class: 'bg-red-100 text-red-800', text: 'Rejet√©' };
      default:
        return { class: 'bg-gray-100 text-gray-800', text: 'Inconnu' };
    }
  }

  /**
   * üìù Obtenir le libell√© du type d'√©valuation
   */
  getEvaluationTypeLabel(type: EvaluationType): string {
    switch (type) {
      case EvaluationType.TuteurToStagiaire:
        return 'Tuteur ‚Üí Stagiaire';
      case EvaluationType.RHToStagiaire:
        return 'RH ‚Üí Stagiaire';
      case EvaluationType.StagiaireToTuteur:
        return 'Stagiaire ‚Üí Tuteur';
      default:
        return 'Type inconnu';
    }
  }

  /**
   * ‚≠ê Obtenir les √©toiles selon le score
   */
  getStarArray(score: number): boolean[] {
    const stars: boolean[] = [];
    for (let i = 1; i <= 5; i++) {
      stars.push(i <= Math.round(score));
    }
    return stars;
  }

  addResponse(ratingId: number, responseDto: RatingResponseDto): Observable<RatingDetailDto> {
  console.log(`üí¨ Ajout d'une r√©ponse √† l'√©valuation ${ratingId}:`, responseDto);
  
  return this.http.post<RatingDetailDto>(`${this.apiUrl}/${ratingId}/response`, responseDto, {
    headers: this.getHeaders()
  }).pipe(
    tap(response => {
      console.log('‚úÖ R√©ponse ajout√©e avec succ√®s:', response);
      this.refreshData();
    }),
    catchError(error => this.handleError(error, 'addResponse'))
  );
}

/**
 * ‚úÖ Approuver une √©valuation
 */
approveRating(ratingId: number, approveDto: ApproveRatingDto): Observable<RatingDetailDto> {
  console.log(`‚úÖ Approbation de l'√©valuation ${ratingId}:`, approveDto);
  
  return this.http.post<RatingDetailDto>(`${this.apiUrl}/${ratingId}/approve`, approveDto, {
    headers: this.getHeaders()
  }).pipe(
    tap(response => {
      console.log('‚úÖ √âvaluation approuv√©e avec succ√®s:', response);
      this.refreshData();
    }),
    catchError(error => this.handleError(error, 'approveRating'))
  );
}

/**
 * ‚ùå Rejeter une √©valuation
 */
rejectRating(ratingId: number, rejectionReason: string): Observable<RatingDetailDto> {
  console.log(`‚ùå Rejet de l'√©valuation ${ratingId} avec raison:`, rejectionReason);
  
  return this.http.post<RatingDetailDto>(`${this.apiUrl}/${ratingId}/reject`, rejectionReason, {
    headers: this.getHeaders()
  }).pipe(
    tap(response => {
      console.log('‚úÖ √âvaluation rejet√©e avec succ√®s:', response);
      this.refreshData();
    }),
    catchError(error => this.handleError(error, 'rejectRating'))
  );
}

/**
 * üîß Diagnostic du service pour debugging
 */
diagnoseService(): void {
  console.group('üîç Diagnostic RatingService');
  console.log('- Is refreshing:', this._isRefreshing);
  console.log('- My ratings count:', this._myRatings$.value.length);
  console.log('- Ratings about me count:', this._ratingsAboutMe$.value.length);
  console.log('- Draft ratings count:', this._draftRatings$.value.length);
  console.log('- Has stats:', this._userStats$.value !== null);
  console.groupEnd();
}



/**
 * üë• R√©cup√©rer les utilisateurs que je peux √©valuer ET qui ne sont pas encore √©valu√©s
 */
getUsersICanRateNotEvaluated(): Observable<any[]> {
  return this.http.get<any[]>(`${this.apiUrl}/users-i-can-rate-not-evaluated`, {
    headers: this.getHeaders()
  }).pipe(
    tap(users => {
      console.log('üë• Utilisateurs √©valuables (endpoint optimis√©):', users.length);
      console.log('üìä D√©tail:', users.map(u => ({ 
        id: u.id, 
        name: `${u.firstName} ${u.lastName}`, 
        role: u.role 
      })));
    }),
    catchError(error => {
      console.error('‚ùå Erreur endpoint optimis√©, fallback vers filtrage client:', error);
      // üîß FALLBACK vers la m√©thode simplifi√©e
      return this.getUsersICanRateWithClientSideFiltering();
    })
  );
}


/**
 * üîß M√âTHODE FALLBACK: Filtrage c√¥t√© client si le backend n'est pas pr√™t
 */
private getUsersICanRateWithClientSideFiltering(): Observable<any[]> {
  return forkJoin({
    availableUsers: this.getUsersICanRate(),
    myRatings: this.getMyRatings()
  }).pipe(
    map(({ availableUsers, myRatings }) => {
      // Extraire les IDs des utilisateurs d√©j√† √©valu√©s
      const evaluatedUserIds = new Set(
        myRatings
          .filter(rating => rating.status !== RatingStatus.Rejected) // Exclure les rejet√©s
          .map(rating => rating.evaluatedUserId)
      );

      // Filtrer les utilisateurs disponibles
      const notEvaluatedUsers = availableUsers.filter(
        user => !evaluatedUserIds.has(user.id)
      );

      console.log('üîç Filtrage c√¥t√© client:');
      console.log('- Utilisateurs disponibles:', availableUsers.length);
      console.log('- Utilisateurs d√©j√† √©valu√©s:', evaluatedUserIds.size);
      console.log('- Utilisateurs non √©valu√©s:', notEvaluatedUsers.length);

      return notEvaluatedUsers;
    }),
    catchError(error => {
      console.error('Erreur lors du filtrage c√¥t√© client:', error);
      // En cas d'erreur, retourner la liste compl√®te
      return this.getUsersICanRate();
    })
  );
}





/**
 * üîß Dernier fallback: filtrage c√¥t√© client
 */
private getGenericRatingsAndFilter(userId: number): Observable<RatingListDto[]> {
  console.log(`üîß Dernier fallback: filtrage c√¥t√© client pour l'utilisateur ${userId}`);
  
  return forkJoin({
    myRatings: this.getMyRatings().pipe(catchError(() => of([]))),
    aboutMeRatings: this.getRatingsAboutMe().pipe(catchError(() => of([])))
  }).pipe(
    map(({ myRatings, aboutMeRatings }) => {
      const allRatings = [...myRatings, ...aboutMeRatings];
      const filtered = allRatings.filter(rating => rating.evaluatedUserId === userId);
      
      // √âliminer les doublons
      const uniqueRatings = filtered.filter((rating, index, self) => 
        index === self.findIndex(r => r.id === rating.id)
      );
      
      console.log(`üéØ Filtrage client: ${uniqueRatings.length} √©valuations pour l'utilisateur ${userId}`);
      return uniqueRatings;
    })
  );
}



/**
 * üëÅÔ∏è R√©cup√©rer les √©valuations re√ßues par un utilisateur sp√©cifique - VERSION CORRIG√âE
 */
getRatingsForUser(userId: number): Observable<RatingListDto[]> {
  console.log(`üîç R√©cup√©ration des √©valuations pour l'utilisateur ${userId}`);
  
  return this.http.get<RatingListDto[]>(`${this.apiUrl}/user/${userId}/received`, {
    headers: this.getHeaders()
  }).pipe(
    tap(ratings => {
      console.log(`‚úÖ ${ratings.length} √©valuations r√©cup√©r√©es pour l'utilisateur ${userId}`);
      ratings.forEach(rating => {
        console.log(`üìã √âvaluation: ID=${rating.id}, Score=${rating.score}, Par=${rating.evaluatorName}`);
      });
    }),
    catchError(error => {
      console.warn(`‚ö†Ô∏è Erreur lors de la r√©cup√©ration des √©valuations pour l'utilisateur ${userId}:`, error);
      
      // üîß FALLBACK am√©lior√©
      return this.getRatingsForUserFallback(userId);
    })
  );
}

/**
 * üìä R√©cup√©rer la moyenne des √©valuations d'un utilisateur - NOUVELLE M√âTHODE
 */
getUserAverageRating(userId: number, type?: EvaluationType): Observable<number> {
  console.log(`üìä R√©cup√©ration de la moyenne pour l'utilisateur ${userId}`);
  
  let params = new HttpParams();
  if (type !== undefined) {
    params = params.set('type', type.toString());
  }
  
  return this.http.get<number>(`${this.apiUrl}/user/${userId}/average`, {
    headers: this.getHeaders(),
    params: params
  }).pipe(
    tap(average => {
      console.log(`‚úÖ Moyenne r√©cup√©r√©e pour l'utilisateur ${userId}: ${average}`);
    }),
    catchError(error => {
      console.warn(`‚ö†Ô∏è Erreur lors de la r√©cup√©ration de la moyenne pour l'utilisateur ${userId}:`, error);
      // En cas d'erreur, calculer c√¥t√© client
      return this.calculateAverageFromRatings(userId, type);
    })
  );
}

/**
 * üîÑ M√©thode de fallback am√©lior√©e pour getRatingsForUser
 */
private getRatingsForUserFallback(userId: number): Observable<RatingListDto[]> {
  console.log(`üîÑ Fallback: tentative alternative pour l'utilisateur ${userId}`);
  
  // Essayer avec des param√®tres sur l'endpoint principal
  let params = new HttpParams().set('evaluatedUserId', userId.toString());
  
  return this.http.get<any>(`${this.apiUrl}`, {
    headers: this.getHeaders(),
    params: params
  }).pipe(
    map(response => {
      // Si la r√©ponse est un objet avec une propri√©t√© ratings
      if (response && response.ratings && Array.isArray(response.ratings)) {
        return response.ratings as RatingListDto[];
      }
      
      // Si la r√©ponse est directement un array
      if (Array.isArray(response)) {
        return response as RatingListDto[];
      }
      
      console.warn('‚ö†Ô∏è Format de r√©ponse inattendu:', response);
      return [];
    }),
    catchError(error => {
      console.error(`‚ùå √âchec total pour l'utilisateur ${userId}:`, error);
      
      // üîß DERNIER FALLBACK: Retourner les √©valuations g√©n√©rales filtr√©es c√¥t√© client
      return this.getGenericRatingsAndFilter(userId);
    })
  );
}

/**
 * üîÑ Calcul c√¥t√© client de la moyenne en cas d'√©chec de l'endpoint
 */
private calculateAverageFromRatings(userId: number, type?: EvaluationType): Observable<number> {
  console.log(`üîÑ Calcul c√¥t√© client de la moyenne pour l'utilisateur ${userId}`);
  
  return this.getRatingsForUser(userId).pipe(
    map(ratings => {
      let filteredRatings = ratings;
      
      if (type !== undefined) {
        filteredRatings = ratings.filter(r => r.type === type);
      }
      
      if (filteredRatings.length === 0) {
        return 0;
      }
      
      const average = filteredRatings.reduce((sum, r) => sum + r.score, 0) / filteredRatings.length;
      console.log(`üßÆ Moyenne calcul√©e c√¥t√© client: ${average.toFixed(2)}`);
      return Math.round(average * 100) / 100;
    }),
    catchError(() => of(0))
  );
}
}